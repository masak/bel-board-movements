(def checkbounds (v max)
  (or (<= 0 v (- max 1)) (ret 'impossible-move)))

(mac zap-as-complex (op (x y) args)
  (letu v
    `(zap (fn (x)
            (zap (fn (y)
                   (set ,v ((op (+ x (* +i y)) ,@args))
                   (ipart ,v))
                 ,y)
            (rpart ,v)
          ,x))))

(tem robot x 0 y 0 dx 0 dy -1)

(def quit (r)
  (ret (list r!x r!y)))

(def move (r f)
  (zap + r!x (f r!dx))
  (zap + r!y (f r!dy)))

(def forward (r)
  (move r idfn))

(def backward (r)
  (move r inv))

(def turn (r angle)
  (zap-as-complex * (r!dx r!dy) angle))

(def turncw (r)
  (turn r +i))

(def turnccw (r)
  (turn r -i))

(set actions `(
  (0 . ,quit)
  (1 . ,forward)
  (2 . ,backward)
  (3 . ,turncw)
  (4 . ,turnccw)))

(mac bindret body
  (letu v
    `(ccc (fn (,v)
       (bind ret ,v
         ,@body)))))

(def run ((w h) (x y) cmds)
  (bindret
    (let r (make robot pos (+ x (* +i y)))
      (map [runcmd r w h _] cmds)
      (list r!x r!y))))

(def runcmd (r w h cmd)
  (aif (get cmd actions)
       (let action (cdr it)
         (action r)
         (checkbounds (x r) w)
         (checkbounds (y r) h))
       (ret 'illegal-command)))
