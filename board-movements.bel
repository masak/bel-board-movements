(tem robot x 0 y 0 dx 0 dy -1)

(def quit (r)
  (throw (list r!x r!y)))

(def move (r f)
  (zap + r!x (f r!dx))
  (zap + r!y (f r!dy)))

(def forward (r)
  (move r idfn))

(def backward (r)
  (move r inv))

(mac zap-as-complex (op (x y) . args)
  (letu v
    `(zap (fn (x)
            (zap (fn (y)
                   (set ,v ((op (+ x (* +i y)) ,@args))
                   (ipart ,v))
                 ,y)
            (rpart ,v)
          ,x))))

(def turn (r angle)
  (zap-as-complex * (r!dx r!dy) angle))

(def turncw (r)
  (turn r +i))

(def turnccw (r)
  (turn r -i))

(set actions `(
  (0 . ,quit)
  (1 . ,forward)
  (2 . ,backward)
  (3 . ,turncw)
  (4 . ,turnccw)))

(def checkbounds (v max)
  (or (<= 0 v (- max 1))
      (throw 'impossible-move)))

(def runcmd (r w h cmd)
  (aif (get cmd actions)
       (let action (cdr it)
         (action r)
         (checkbounds r!x w)
         (checkbounds r!y h))
       (throw 'illegal-command)))

(def run ((w h) (x y) cmds)
  (catch
    (let r (make robot x x y y)
      (map [runcmd r w h _] cmds)
      (list r!x r!y))))
