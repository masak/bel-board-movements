(tem robot x 0 y 0 dx 0 dy -1)

(set actions nil)

(mac defaction (cmd name parms . body)
  `(push (cmd . (fn ,parms ,@body)) actions))

(defaction 0 quit (r)
  (throw (list r!x r!y)))

(def move (r f)
  (zap + r!x (f r!dx))
  (zap + r!y (f r!dy)))

(defaction 1 forward (r)
  (move r idfn))

(defaction 2 backward (r)
  (move r inv))

(mac zap-as-complex (op (x y) . args)
  (letu v
    `(zap (fn (x)
            (zap (fn (y)
                   (set ,v ((op (+ x (* +i y)) ,@args))
                   (ipart ,v))
                 ,y)
            (rpart ,v)
          ,x))))

(def turn (r angle)
  (zap-as-complex * (r!dx r!dy) angle))

(defaction 3 turncw (r)
  (turn r +i))

(defaction 4 turnccw (r)
  (turn r -i))

(def checkbounds (v max)
  (or (<= 0 v (- max 1))
      (throw 'impossible-move)))

(def runcmd (r w h cmd)
  (aif (get cmd actions)
       (let action (cdr it)
         (action r)
         (checkbounds r!x w)
         (checkbounds r!y h))
       (throw 'illegal-command)))

(def run ((w h) (x y) cmds)
  (catch
    (let r (make robot x x y y)
      (map [runcmd r w h _] cmds)
      (list r!x r!y))))
